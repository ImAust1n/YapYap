<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Speech2Text Monitor</title>
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js" defer></script>
    <style>
      :root {
        color-scheme: light dark;
        --bg: #0f172a;
        --card: #1e293b;
        --accent: #38bdf8;
        --accent-strong: #0ea5e9;
        --text-primary: #f8fafc;
        --text-muted: #94a3b8;
        --success: #4ade80;
        --danger: #f87171;
        --shadow: 0 20px 40px -24px rgba(15, 23, 42, 0.7);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", sans-serif;
        background: radial-gradient(circle at top left, #1e293b, #0f172a 60%);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        padding: 3rem 1.5rem;
      }

      .container {
        width: min(1100px, 100%);
        display: grid;
        gap: 2rem;
      }

      header {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      header h1 {
        margin: 0;
        font-size: clamp(1.8rem, 4vw, 2.6rem);
        font-weight: 700;
        letter-spacing: -0.03em;
      }

      header p {
        margin: 0;
        color: var(--text-muted);
        font-size: 0.95rem;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.45rem 0.9rem;
        border-radius: 999px;
        font-size: 0.85rem;
        background: rgba(56, 189, 248, 0.1);
        color: var(--accent);
        border: 1px solid rgba(56, 189, 248, 0.3);
      }

      .card {
        background: rgba(30, 41, 59, 0.82);
        border: 1px solid rgba(148, 163, 184, 0.08);
        border-radius: 20px;
        box-shadow: var(--shadow);
        padding: 1.75rem;
        backdrop-filter: blur(16px);
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
        justify-content: space-between;
      }

      .controls h2,
      .section-title {
        margin: 0;
        font-size: 1.25rem;
        font-weight: 600;
      }

      .button-group {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      button {
        appearance: none;
        border: none;
        padding: 0.75rem 1.4rem;
        border-radius: 12px;
        font-size: 0.95rem;
        font-weight: 600;
        letter-spacing: -0.01em;
        cursor: pointer;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 0.45rem;
        box-shadow: 0 12px 20px -12px rgba(14, 165, 233, 0.65);
      }

      button.primary {
        background: linear-gradient(135deg, var(--accent), var(--accent-strong));
        color: #0f172a;
      }

      button.secondary {
        background: rgba(148, 163, 184, 0.15);
        color: var(--text-primary);
        box-shadow: none;
      }

      button:disabled {
        cursor: not-allowed;
        opacity: 0.5;
        box-shadow: none;
      }

      .tone-toolbar {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        padding: 0.5rem 0.75rem;
        border-radius: 12px;
        background: rgba(148, 163, 184, 0.12);
      }

      .tone-toolbar label {
        font-size: 0.9rem;
        color: var(--text-muted);
        letter-spacing: 0.04em;
      }

      .tone-select {
        appearance: none;
        border: 1px solid rgba(148, 163, 184, 0.3);
        background: rgba(15, 23, 42, 0.85);
        color: var(--text-primary);
        border-radius: 10px;
        padding: 0.55rem 1.1rem;
        font-size: 0.95rem;
        font-family: inherit;
      }

      .tone-select:focus {
        outline: 2px solid rgba(56, 189, 248, 0.4);
        outline-offset: 1px;
      }

      .tone-apply {
        padding: 0.6rem 1.1rem;
        font-size: 0.9rem;
        box-shadow: none;
      }

      .status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 1.2rem;
        margin-top: 1.25rem;
      }

      .status-item {
        padding: 1rem 1.2rem;
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.75);
        border: 1px solid rgba(148, 163, 184, 0.08);
      }

      .status-item span {
        display: block;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-muted);
        margin-bottom: 0.4rem;
      }

      .status-item strong {
        font-size: 1.15rem;
        font-weight: 600;
      }

      .status-indicator {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.6rem 1rem;
        border-radius: 999px;
        font-size: 0.88rem;
        font-weight: 500;
        background: rgba(56, 189, 248, 0.12);
        color: var(--accent);
        border: 1px solid rgba(56, 189, 248, 0.4);
      }

      .status-indicator.offline {
        background: rgba(248, 113, 113, 0.12);
        color: var(--danger);
        border-color: rgba(248, 113, 113, 0.4);
      }

      .status-indicator::before {
        content: "";
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: currentColor;
        box-shadow: 0 0 12px rgba(56, 189, 248, 0.55);
      }

      .status-indicator.offline::before {
        box-shadow: 0 0 10px rgba(248, 113, 113, 0.4);
      }

      .status-meta {
        margin-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        color: var(--text-muted);
        font-size: 0.85rem;
      }

      .transcripts {
        display: grid;
        gap: 1.5rem;
      }

      .transcripts header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
      }

      .transcript-content {
        display: grid;
        gap: 1.25rem;
      }

      @media (min-width: 820px) {
        .transcript-content {
          grid-template-columns: minmax(0, 320px) 1fr;
        }
      }

      .transcript-box {
        padding: 1.15rem 1.35rem;
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.75);
        border: 1px solid rgba(148, 163, 184, 0.08);
        display: grid;
        gap: 0.75rem;
        min-height: 140px;
      }

      .transcript-box h3 {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }

      .live-text {
        margin: 0;
        font-size: 1.1rem;
        line-height: 1.6;
      }

      .paragraph-text {
        margin: 0;
        font-size: 1rem;
        line-height: 1.7;
        color: var(--text-primary);
        white-space: pre-wrap;
      }

      .latency-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.85rem;
        padding: 0.5rem 0.75rem;
        border-radius: 10px;
        background: rgba(56, 189, 248, 0.12);
        color: var(--accent);
      }

      .latency-pill.hidden {
        display: none;
      }

      .chart-wrapper {
        position: relative;
        height: 320px;
      }

      .error-banner {
        margin-top: 1rem;
        padding: 0.75rem 1rem;
        border-radius: 10px;
        background: rgba(248, 113, 113, 0.15);
        color: var(--danger);
        font-size: 0.9rem;
        display: none;
      }

      @media (max-width: 768px) {
        body {
          padding: 2rem 1rem;
        }
        .controls {
          flex-direction: column;
          align-items: stretch;
        }
        .button-group {
          width: 100%;
        }
        button {
          justify-content: center;
          flex: 1;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <div>
          <h1>Speech2Text Live Monitor</h1>
          <p>
            Real-time whisper transcription pipeline with automated cleanup,
            tone control, and latency telemetry.
          </p>
        </div>
        <span id="status-indicator" class="status-indicator offline">
          Offline
        </span>
      </header>

      <section class="card controls">
        <div>
          <h2>Pipeline Controls</h2>
          <div class="status-meta" id="status-meta"></div>
        </div>
        <div class="button-group">
          <button id="start-btn" class="primary">▶ Start Capture</button>
          <button id="stop-btn" class="secondary">■ Stop Capture</button>
          <div class="tone-toolbar">
            <label for="tone-select">Tone</label>
            <select id="tone-select" class="tone-select">
              <option value="neutral">Neutral</option>
              <option value="formal">Professional</option>
              <option value="casual">Casual</option>
            </select>
            <button id="tone-apply" class="secondary tone-apply">Apply</button>
          </div>
        </div>
      </section>

      <section class="card">
        <h2 class="section-title">System Metrics</h2>
        <div class="status-grid" id="metrics-grid"></div>
        <div id="error-banner" class="error-banner"></div>
      </section>

      <section class="card transcripts">
        <header>
          <h2 class="section-title">Live Transcripts</h2>
          <span class="badge" id="history-count">Fetching…</span>
        </header>
        <div class="transcript-content">
          <div class="transcript-box">
            <h3>Current Sentence</h3>
            <p id="current-utterance" class="live-text">Waiting for audio…</p>
            <div id="current-meta" class="latency-pill hidden"></div>
          </div>
          <div class="transcript-box">
            <h3>Transcript</h3>
            <p id="transcript-paragraph" class="paragraph-text">
              The live transcript will appear here once speech is detected.
            </p>
          </div>
        </div>
      </section>

      <section class="card">
        <header>
          <h2 class="section-title">Latency Timeline</h2>
          <span class="badge">Milliseconds (ms)</span>
        </header>
        <div class="chart-wrapper">
          <canvas id="latency-chart" aria-label="Latency chart"></canvas>
        </div>
      </section>
    </div>

    <script>
      const statusIndicator = document.getElementById("status-indicator");
      const statusMeta = document.getElementById("status-meta");
      const metricsGrid = document.getElementById("metrics-grid");
      const transcriptParagraph = document.getElementById("transcript-paragraph");
      const currentUtterance = document.getElementById("current-utterance");
      const currentMeta = document.getElementById("current-meta");
      const historyBadge = document.getElementById("history-count");
      const errorBanner = document.getElementById("error-banner");
      const startBtn = document.getElementById("start-btn");
      const stopBtn = document.getElementById("stop-btn");
      const toneSelect = document.getElementById("tone-select");
      const toneApply = document.getElementById("tone-apply");

      const MAX_GRAPH_POINTS = 60;
      const POLL_INTERVAL_MS = 3000;
      const TONE_LABELS = {
        neutral: "Neutral",
        formal: "Professional",
        casual: "Casual",
      };

      let latencyChart;

      function formatLatency(ms) {
        if (ms == null || Number.isNaN(ms)) return "–";
        return `${ms.toFixed(1)} ms`;
      }

      function formatTone(tone) {
        const normalized = (tone || "neutral").toLowerCase();
        return TONE_LABELS[normalized] || "Neutral";
      }

      function formatDate(isoString) {
        if (!isoString) return "";
        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) return isoString;
        return date.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        });
      }

      function setStatusIndicator(active) {
        statusIndicator.textContent = active ? "Streaming" : "Offline";
        statusIndicator.classList.toggle("offline", !active);
      }

      function renderMetrics(status) {
        const items = [
          {
            label: "Device",
            value: `${status.device?.toUpperCase() || "–"} (${status.compute_type})`,
          },
          { label: "Sample Rate", value: `${status.sample_rate} Hz` },
          { label: "Chunk Window", value: `${status.chunk_seconds} s` },
          { label: "Tone Mode", value: formatTone(status.tone_mode) },
          { label: "History", value: status.history_size ?? 0 },
        ];

        metricsGrid.innerHTML = items
          .map(
            (item) => `
              <div class="status-item">
                <span>${item.label}</span>
                <strong>${item.value}</strong>
              </div>
            `
          )
          .join("");

        statusMeta.textContent = status.latest
          ? `Latest update ${formatDate(status.latest.timestamp)} · Last utterance latency ${formatLatency(
              status.latest.processed_latency_ms
            )}`
          : "Awaiting audio…";

        if (toneSelect) {
          const toneValue = (status.tone_mode || "neutral").toLowerCase();
          toneSelect.value = TONE_LABELS[toneValue] ? toneValue : "neutral";
        }
      }

      function renderTranscripts(data) {
        const { paragraph = "", current = null, count = 0 } = data ?? {};

        historyBadge.textContent = `${count} entries`;

        const currentText = current?.text?.trim();
        if (currentText) {
          currentUtterance.textContent = currentText;
        } else {
          currentUtterance.textContent = "Waiting for audio…";
        }

        const raw = current?.raw_latency_ms;
        const processed = current?.processed_latency_ms;
        const preprocess = current?.preprocessing_total_ms;

        if (current && (raw != null || processed != null || preprocess != null)) {
          currentMeta.innerHTML = `
            <span>Raw: ${formatLatency(raw)}</span>
            <span>Proc: ${formatLatency(processed)}</span>
            <span>Pre: ${formatLatency(preprocess)}</span>
          `;
          currentMeta.classList.remove("hidden");
        } else {
          currentMeta.classList.add("hidden");
          currentMeta.textContent = "";
        }

        const paragraphText = paragraph?.trim();
        transcriptParagraph.textContent = paragraphText || "The live transcript will appear here once speech is detected.";
      }

      function ensureChart(canvas) {
        if (latencyChart) return latencyChart;

        const context = canvas.getContext("2d");
        latencyChart = new Chart(context, {
          type: "line",
          data: {
            labels: [],
            datasets: [
              {
                label: "Raw latency",
                data: [],
                borderColor: "#38bdf8",
                backgroundColor: "rgba(56, 189, 248, 0.15)",
                cubicInterpolationMode: "monotone",
                tension: 0.35,
                fill: false,
              },
              {
                label: "Processed",
                data: [],
                borderColor: "#4ade80",
                backgroundColor: "rgba(74, 222, 128, 0.12)",
                cubicInterpolationMode: "monotone",
                tension: 0.35,
                fill: false,
              },
              {
                label: "Pre-processing total",
                data: [],
                borderColor: "#f97316",
                backgroundColor: "rgba(249, 115, 22, 0.12)",
                cubicInterpolationMode: "monotone",
                tension: 0.35,
                fill: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: "nearest",
              intersect: false,
            },
            scales: {
              x: {
                ticks: {
                  color: "#cbd5f5",
                },
                grid: {
                  color: "rgba(148, 163, 184, 0.1)",
                },
              },
              y: {
                beginAtZero: true,
                ticks: {
                  color: "#cbd5f5",
                  callback: (value) => `${value} ms`,
                },
                grid: {
                  color: "rgba(148, 163, 184, 0.08)",
                },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: "#e2e8f0",
                },
              },
              tooltip: {
                callbacks: {
                  label: (context) => `${context.dataset.label}: ${context.parsed.y.toFixed(1)} ms`,
                },
              },
            },
          },
        });

        return latencyChart;
      }

      function updateChart(items) {
        const chart = ensureChart(document.getElementById("latency-chart"));
        const sorted = [...items].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        const trimmed = sorted.slice(-MAX_GRAPH_POINTS);

        chart.data.labels = trimmed.map((item) => formatDate(item.timestamp));
        chart.data.datasets[0].data = trimmed.map((item) => item.raw_latency_ms ?? 0);
        chart.data.datasets[1].data = trimmed.map((item) => item.processed_latency_ms ?? 0);
        chart.data.datasets[2].data = trimmed.map((item) => item.preprocessing_total_ms ?? 0);
        chart.update("none");
      }

      async function fetchJson(url, options) {
        const response = await fetch(url, options);
        if (!response.ok) {
          const text = await response.text();
          throw new Error(text || response.statusText);
        }
        return response.json();
      }

      async function refreshDashboard() {
        try {
          const [status, transcripts] = await Promise.all([
            fetchJson("/api/status"),
            fetchJson("/api/transcripts?limit=60"),
          ]);

          setStatusIndicator(status.capture_active);
          renderMetrics(status);

          renderTranscripts(transcripts);
          updateChart(transcripts.items ?? []);

          errorBanner.style.display = "none";
          errorBanner.textContent = "";
        } catch (error) {
          console.error("Dashboard refresh failed:", error);
          errorBanner.style.display = "block";
          errorBanner.textContent = `Failed to refresh dashboard: ${error.message}`;
          setStatusIndicator(false);
        }
      }

      async function sendControl(action) {
        startBtn.disabled = true;
        stopBtn.disabled = true;
        try {
          await fetchJson("/api/control", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ action }),
          });
          await refreshDashboard();
        } catch (error) {
          errorBanner.style.display = "block";
          errorBanner.textContent = `Control command failed: ${error.message}`;
        } finally {
          startBtn.disabled = false;
          stopBtn.disabled = false;
        }
      }

      async function sendTone() {
        if (!toneSelect) return;

        const toneValue = toneSelect.value;
        toneSelect.disabled = true;
        toneApply.disabled = true;
        try {
          await fetchJson("/api/tone", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ tone: toneValue }),
          });
          await refreshDashboard();
          errorBanner.style.display = "none";
          errorBanner.textContent = "";
        } catch (error) {
          console.error("Tone update failed:", error);
          errorBanner.style.display = "block";
          errorBanner.textContent = `Failed to update tone: ${error.message}`;
        } finally {
          toneSelect.disabled = false;
          toneApply.disabled = false;
        }
      }

      function initControls() {
        startBtn.addEventListener("click", () => sendControl("start"));
        stopBtn.addEventListener("click", () => sendControl("stop"));
        toneApply.addEventListener("click", sendTone);
      }

      document.addEventListener("DOMContentLoaded", () => {
        initControls();
        ensureChart(document.getElementById("latency-chart"));
        refreshDashboard();
        setInterval(refreshDashboard, POLL_INTERVAL_MS);
      });
    </script>
  </body>
</html>
